-*- outline -*-
概念术语这样表示：*术语*
强调词汇这样表示：_强调_




* Scheme解释器实现的相关重要内容
** 代码的内部表示
** 类型系统
** 垃圾回收
** 词法解析
** 表达式求值的环境模型
** 寄存器机器模型（是否必要？）
** 尾递归的原理与实现
** 基本运算符集

* 表达式求值的环境模型
** 相关摘录 SICP 3.2 P162

表达式求值模型有两种：代换模型和环境模型。

不用任何赋值的程序设计称为*函数式程序设计*；采用赋值的称为*命令式程序设计*。

函数式程序设计中，可以采用代换模型。因为以同样的参数对同一过程的两次求值
一定产生出同样的结果，可以认为过程是在计算数学函数。代换模型是具有”漂亮
“数学性质的简单模型。

*** 环境模型

一个*环境*就是*框架*（frame）的一个序列，每个框架是包含着一些*约
束*（binding）的一个表格（可能为空），这些约束将一些变量名字关联于对应的值
（在一个框架里，任何变量至多只能有一个约束）。每个框架还包含着一个指针，指
向这一框架的*外围环境*（enclosing environment）。一个*变量*（variable）相对
于某个特定环境的*值*（value），也就是在这一环境中，包含着该变量的第一个框架
里这个变量的约束值。如果在序列中并不存在这一变量的约束，那么我们就说该变
量在该特定环境中是*无约束*（unbound）的。

如果在当前框架中找不到某个变量的约束，则应转到其外围环境中去查找。

*** define的行为：作用于框架的
用define定义一个符号，就是在当前环境_框架_里建立一个约束，如果在当前框架
中已经有了对这一变量的约束，那么约束就会改变。它不会去外围环境查找该符号
的约束，因此称define是作用于框架的。

*** set!的行为：作用于环境的
在某个环境里求值表达式(set! <variable> <value>)，要求我们首先在_环境_中
确定有关变量的约束位置，而后再修改这个约束，使之表示新值。这也就是说，首先
需要找到包含这个变量的约束的第一个框架，而修改这一框架。如果该变量在_环
境_中没有约束，set!将报告一个错误。

*** 过程应用的环境模型总结
1 将一个过程对象应用于一集实际参数，将构造出一个新框架，其中将过程的形式
参数约束到调用时的实际参数，而后在构造起的这一新环境的上下文中求值过程体。
这个新框架的外围环境就是被应用的那个过程对象所处的环境。

2 相对于一个给定环境求值一个lambda表达式，将创建起一个过程对象，这个过程
对象是一个_序对_，由该lambda表达式的正文和一个指向环境的指针组成，这一指
针指向的就是创建这个过程对象时的环境。

** 环境模型的实现
*** 接口
环境需要对外提供一些操作接口。
**** 查找变量的值－lookup variable's value
返回此环境中相应符号的约束值，若没有该符号的约束就抛出一个错误。
**** 扩展环境－extend a environment with variables and values
返回一个新环境，这个环境中包含了一个新的框架，其中的所有位于变量表中的符
号约束到值表里对应的元素，而其外围环境就是此环境。
**** 定义变量（添加约束）－define variable
在环境的第一个框架里加入一个新的约束，它关联起给定的符号和值。如果第一个
框架中已经有该变量的约束，则修改它。
**** 修改变量－set variable's value
修改变量在环境里的约束，使得该变量约束到给定的值。如果没有这一变量的约束
就抛出一个错误。
*** 实现
“一个环境就是一个框架的序列，每个框架都是一个约束的表格，其中的约束关联起
一些变量和与这对应的值。”（SICP4.1.3 P261）

约束用pair来表示，框架用约束的list来表示，环境用框架的list来表示。这样就
跟SICP4.1.3 P261中练习4.11的实现一样了，同时也与整个Scheme的类型系统为一个整
体了。等全部实现后，若因效率问题，还可以修改这一表示，而不影响其接口。

* 代码的内部表示
原子（atom）是Scheme的基本单位。它可以是原子、空表（null）和由原子组成的表。

atom := atom | null list | list
list := (atom*)

** 共享如何实现？

SICP P177 共享和相等

这一节中引入了共享，一些序对或符号可能同时被多个对象所引用（不知道其它类
型的对象是否也有此现象，如字符、数值等）。但是这种共享应该如何实现，如何
找到已有的这些东西？难道要维护一个所有对象的HASH表吗？或用**设计模式？

使用Flyweight模式，但要注意可能有些对象不能共享，如字符串，向量等，当然这还
要取决于是具体实现。

* 类型系统

参考R5RS

** 互不相交的类型

boolean? 布尔
pair? 点对
symbol? 符号
number? 数值
char? 字符
string? 字符串
vector? 向量
port? 端口
procedure? 过程
null? 空表

空表 － 空表是一个隶属于自身类型的特殊对象，它不能满足基本任何一个谓词。
但它也属于表。


其它谓词：

list? 表 － 满足此谓词的对象也满足pair?或null?

      	 (list? '(a b c))                        => #t
         (list? '())                             => #t
         (list? '(a . b))                        => #f

常量和symbol->string过程返回的字符串是不可变的对象，本报告列举的其他过程
创建的所有对象都是可变的对象。


类层次结构




* 寄存器机器模型

** 有以下寄存器：

exp - 掌握被求值的表达式
env - 求值的进行所在的环境
val - 求值结束时，保存着通过在指定环境里求值表达式得到的结果
continue - 用于实现递归

下面的寄存器用于求值组合式的时候。
proc - 指向操作符
argl - 积累对运算对象求值的结果
unev - 

在求值lambda表达式时（即创建函数对象），令unev保存参数列表，exp保存函数体代码序列，env保
存当前环境，然后创建函数对象（unev exp env），并保存到val中。

求值过程应用（即组合式）时，首先求值运算符以产生出一个过程，并将它移入
proc寄存器。若有运算对象，则需要先保存proc寄存器，然后依次求值运算对
象，并将结果积累到argl中。在求值时，将参数表保存到unev中，实现参数已经
在argl中，并由些创建起新的框架，以过程所保存的环境作为外围框架，并将整个
环境保存到env中，然后将过程体保存到unev中，并依次对其中的表达式求值。

栈 - 调用程序之前用于存放相关的寄存器的值。

** 执行过程（与环境操作相结合）

初始设置继续为结束位置，并在环境中加入一些默认的约束，如基本函数、空表等。

向机器中加入要执行的代码，即设置PC的值，令其指向要执行的代码。

（向环境中加入变量约束，）然后启动机器，依次执行PC指向的代码。

要应用复合函数时，先保存继续，并设置继续为当前PC的值，再保存需要的变量
约束。而后从环境中找到复合函数的定义代码，并在复合函数约束的框架中创建
子框架，在其中将实际参数与参数表对应约束起来。然后将子框架作为当前框
架，在其中依次求值表达式的值，并总将求得的值保存在寄存器“值”中（此处对
最后一个表达式特殊处理可实现尾递归）。

当函数返回时，其值已经在“值”中了。将continue恢复，然后按相反顺序将保存
的变量约束恢复，再

将参数约束到要应用的函数的环境中，然后
执行子函数的代码


* 停止并复制垃圾回收机制
** 步骤
1 初始化free和scan指针到新的开始位置
2 将root所指向的序对（根）重新分配到新存储区的开始位置
3 令root指针也指向这一新位置，free指针的值被增加
4 在这一根序对原来位置的car部分加上broken heart标志，cdr部分放置前向指
针，指向该序对的新位置。

（下面进入基本循环）此时，扫描指针scan指向的是一个本身已经移入新存储区
的对象，但其car和cdr仍然指向老存储区里的对象。现在就要重新分配这样的被
指对象，并相应增加scan的值。

  
5 如果scan < free,令scan-obj = (car scan)；否则转到（11）
6 如果(car scan-obj)为broken heart标志，则转到（9）；否则继续
7 为scan-obj分配新空间，即将其拷贝到free所指地方，并增加free的值
8 令scan的car域指向新空间
9 令scan的car域指向(cdr scan-obj)所指的位置
10 令scan-obj = (cdr scan),转到（6）
11 

* scheme的设计理念
Scheme作为Lisp语言的一个分支，与1975年由Sussman和他的学生Guy Steele,Jr
一起完成。Scheme的理念是程序语言不是拿来“学”的，而是拿来“用”的。Scheme
诞生后，由于其具有所有Lisp的优点，而且干净、强大、稳定、特别适合用于描
述算法，以至于Scheme在教育界被广泛的使用，新一代优秀的计算机科学家中很
多人的“母语”就是Scheme。

* 对SICP的评价
SICP展示了计算机科学的核心所在，它是用来教你如何成为一个计算机科学家，
而不是程序员。



男人的心只能爱一次，那一次以后，所有的邂逅都将是理智的，只要在他的理智
中，你受到了重视，那你在他心里的地位就已经存在，这就够了。
